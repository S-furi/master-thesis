%!TEX root = ../thesis-main.tex
\chapter{An Introduction to Simulation}\label{ch:introduction}
The scientific method is characterised by the formulation of a \emph{theory}
which needs to be proven as false or true. This forms the first scientific
pillar, which is the theoretical assumption and knowledge used to describe a
certain phenomena, a property or a behaviour. The process of gathering evidence
to support the validity of the theory is what \emph{experiments} try to
accomplish, namely a series of observations of the real world that confirm or
refute the initial hypothesis. In the modern era of sciences, computer systems
backs the vast majority of modern scientific discoveries, whether through the
usage of the raw computing power (e.g. weather forecasting equations resolution
through Massively Parallel Computers) of such systems or by exploiting virtual
representations of the real world ~\cite{Post2005-kn}. With the widespread
adoption of simulation and simulators in the scientific method, researchers are
now considering simulation as the \emph{third pillar} of science which
complements theory and experiments. Some argues that simulation cannot be
compared to experimentation, while others claim that there is more in common
between simulation and experimentation ~\cite{WinsbergEric2010Sita}.
In the general scientific method framework, theory provides the model of the
hypothesis, while through experiments some may validate those models against
reality, while simulation can serve as sources of new insights or new
hypothesis which will be tested experimentally. Therefore, simulation is
essential in most scientific development workflows, and modern literature has
plenty of successful applications of simulations in various fields from biology
to physics and from chemistry to social sciences.

\section{Simulation and Modelling}

\subsection{System Modelling concepts}

Systems modeling and more in general system theory, is very important in
numerous problem areas, most notably in the study and understand of
unpredictable phenomena or large-scale and complex systems through a precise,
general and elegant mathematical theory capable of being both concerned in the
goal seeking and with the input-output causal representation
~\cite{mesarovic1975general}.

A framework of modeling and simulation define entities and their relationships as illustrated
in \Cref{fig:ms_framework}. 
%
\includediagram[0.8\linewidth]{figures/diagrams/entities_ms.tex}{The Modeling and Simulation Framework.}{fig:ms_framework}
%
\begin{itemize}
	\item the \emph{source system} is the real or virtual environment under
		study, serving as the source of behavioural data.
	\item the \emph{model} is a set of instructions, rules, equations or
		constraints which form a logical representation of the system;
	\item the \emph{simulation} is the computational device (e.g. an
		algorithm) that interprets the model's instructions to generate
		state trajectories over time;
	\item the \emph{experimental frame} is a specification of the
		conditions under which the system is observed or experimented
		with.
\end{itemize}
A fundamental concept linking these entities is the \emph{State}. According to
~\cite{Zeigler:2000}, the state of a system at a given time $t$ is defined as
the information required to determine the system's output and future behaviour,
under the assumption that future inputs are know.

\subsection{The Simulation Framework}
[definition of the simulation framework]

We could define the general simulation framework formally by means of the \emph{general system tuple}~\cite{Zeigler:2000}:
\begin{equation}
	S = \langle T, X, Y, Q, \Omega, \delta, \lambda \rangle
\end{equation}
Where:

\begin{itemize}
	\item $T$: \emph{Time Base}, whether $T \in \mathbb{R}$ or $T \in \mathbb{Z}$;
	\item $X$: the set of \emph{Input Values};
	\item $Y$: the set of \emph{Output Values};
	\item $Q$: the set of \emph{States};
	\item $\Omega$: the set of admissible \emph{Input Segments} (functions of time);
	\item $\delta : Q \times \Omega \rightarrow Q $: the \emph{state transition function};
	\item $\lambda : Q \times X \rightarrow Y$: the \emph{output function}.
\end{itemize}
[continue here]

\section{Simulation Formalisms}

\subsection{Discrete Time Simulators}\label{ssec:dts}

The Discrete Time Model assumes a \emph{stepwise} mode of execution where, at a
particular time instant, the model is in a particular state and it defines how
this state changes. Based on its current state and the current input, the model
can determine which will be its state and output in the next time instant.
\emph{Time} in discrete time models advances in discrete steps of integers
multiple of some basic period such as 1 second, 1 day or 1 year.

A discrete time model determines its next state and output at a given time
$t$ with the following functions:

\begin{subequations}
	 \begin{align}
		q(t + 1) & = \delta(q(t), x(t)) \label{eq:state_transition} \\
		y(t) & = \lambda(q(t), x(t)) \label{eq:output_transition}
	 \end{align}
\end{subequations}
Starting from an initial state $q(0)$, we determine the \emph{state trajectory}
$q(0), q(1), \dots$ by applying the \emph{state transition function}
\eqref{eq:state_transition}; similarly, by applying the \emph{output function}
\eqref{eq:output_transition} to the initial state, we obtain the \emph{output
trajectory}.

\paragraph{Cellular Automata as Discrete Time Models:}

With these simple functions a wide spectrum of potentially interesting and
arbitrary complex models could be created. A notable example of modeling and
thereafter simulating models defined through simple state transition and output
functions are \emph{Cellular Automata} ~\cite{Neumann:66}. A
cellular automaton has a set of \emph{cells} (potentially infinite) spatially
located in a grid-like space, where each one of them could have a finite set of
states determined by a set of state transition functions identical for each
cell. State transition functions could be influenced by the
\emph{neighbourhood} of the cell, which most of the time is defined as the set
of cells located nearest in the geometrical sense.

The basic procedure for simulating a cellular automaton is by means of the
discrete time simulation algorithm: at each time tick, every cell of the
environment is scanned and the state transition function is applied,
effectively changing states for those cells whose state transition function
produced a new state different from its current. When all next states have been
computed, the current configuration of all cells constitute the new global
state, and the global tick can advance.

It is rather obvious that either for infinite environment or for particularly
large and complex cellular automata, this approach is unfeasible. If at each
time step we could, instead, ``predict'' which cells could change in the next
time step, the amount of state computation for each step is dramatically
reduced (e.g. in Conway's Game of Life). We could define which cells will
change in the next time step as the cells whose neighboring cells have not
changed at the current state transition time. This key idea is behind the
Discrete Event Simulation algorithm, which focuses on processing events (a cell
state change which will trigger a computation of new possibile states for its
neighbours) rather than single cells.

\subsection{Differential Equation Simulators}\label{ssec:dess}

Unlike Discrete Time Models and Discrete Event Models (discussed later in
\Cref{ssec:devs}) where state changes happen at specific time instants, in
Differential Equations Models the next state is not specified directly but a
\emph{rate of change} of the state variables is used to express the evolution
of the model through time. This means that at any particular time instant $t$,
given a state $z$ and an input value $u$, we only know the rate of change of
the state, defined as:
%
\begin{equation}
	\frac{dz}{dt} = f(z, u)
\end{equation}
%
Typically continuous time systems are expressed by using several state
variables, meaning that a continuous time model is formed by a set of \ac{ODE}.
Therefore we can express the \emph{state equation} representation of \ac{ODE}
as:
%
\begin{equation}
	\frac{d\mathbf{z}(t)}{dt} = \mathbf{f}(\mathbf{z}(t), \mathbf{u}(t))
\end{equation}
%
where $\mathbf{z}(t) \triangleq [z_1(t), z_2(t), \dots, z_n(t)]^T$ is the state
vector, the input vector $\mathbf{u}(t) \triangleq [u_1(t), u_2(t), \dots,
u_n(t)]$ and $\mathbf{f} \triangleq [f_1, f_2, \dots, f_n]$ is the vector of
differential equations.

To obtain the state trajectory, the \ac{ODE} must be solved. Solving an
\ac{ODE} \emph{analytically} is often impossible, especially for non-linear
systems. Therefore, simulations utilize numerical integration methods (e.g.
Euler's method, Runge-Kutta for one-step methods, ...). It is also important to
note that because digital computers operate in discrete steps, simulating a
Differential Equation System effectively reduces it to a form of Discrete Time
System. The numerical solver discretises time into small steps $\Delta t$,
calculating ~\cite{cellier2006continuous}:
%
\begin{equation}
    \mathbf{z}(t + \Delta t) \approx \mathbf{z}(t) + \mathbf{f}(\mathbf{z}(t), \mathbf{u}(t)) \cdot \Delta t
\end{equation}
%
Thus, in the context of computer simulation, DESS is often treated as a
special, computationally intensive case of discrete time simulation
~\cite{law2007simulation} with a very fine temporal granularity.

\subsection{Discrete Event Simulators}\label{ssec:devs}
While Discrete Time models advance in fixed steps, Discrete Event models are
characterised by a continuous time base where state changes occur only at
discrete instants called \emph{events}. Between two consecutive events, the
system's state remains unchanged, allowing the simulator to jump over periods
of inactivity, making \ac{DES} highly efficient for sparse systems.

A Discrete Event System (DEVS) can be specified as:
%
\begin{equation}
	M = \langle X, S, Y, \delta_{\text{int}}, \delta_{\text{ext}}, \lambda, \text{ta} \rangle
\end{equation}
%
Where the key components distinguishing from DTSS and DESS are:
\begin{itemize}
	\item \textbf{Time Advance} $\text{ta}: S \rightarrow \mathbb{R}^+_{0,
		\infty}$: a function returning the system remains in a
		particular state if no external events occur, defining the
		lifespan of a state. If $\text{ta}(s) = 0$ the state is so
		short that no other event can intervene (\emph{transitory
		state}), whereas $\text{ta}(s) = \infty$ means that the system
		remains in $s$ indefinitely, unless interrupted by an external
		event;
	\item \textbf{Internal Transition} $\delta_{\text{int}}: S \rightarrow S$: this
		function dictates the new state $s' : \delta_{\text{int}}(s) =
		s'$ after the time $\text{ta}(s)$ has elapsed (autonomous state
		change);
	\item \textbf{External Transition} $\delta_{\text{ext}}: Q \times X
		\rightarrow S$: given the total state set $Q = \{ (s, e) : s
		\in S, 0 \leq e \leq \text{ta}(s)\}$, this function dictates
		the new state $s' = \delta_{\text{ext}}(s, x, e)$ when an input
		$x$ is received in state $s$ after elapsed time $e$.
\end{itemize}
Through this formal definition we can highlight that time in DEVS is not a
global ticker, but a derived property of the system's state via the time
advance function.

\paragraph{DES Simulation Mechanism (Event Scheduling):} To execute a formal
DEVS model on a digital computer, the most common approach is by the
\emph{Event Scheduling} method ~\cite{BanksDESS10}. The simulator maintains a
strictly ordered data queue known as the \ac{FEL}, which stores pending events
ordered by their execution time.
The execution proceeds as a sequence of system \emph{snapshots}:
%
\begin{enumerate}
	\item The clock is advanced to the time of the imminent event at the head of the \ac{FEL};
	\item The event is removed from the \ac{FEL} and executed (either applying $\delta_{\text{int}}$ or $\delta_{\text{ext}}$);
	\item The execution may generate new events or cancel or update existing ones by updating the contents of the \ac{FEL};
	\item The process repeats until \ac{FEL} is empty or a termination condition occurs.
\end{enumerate}
%
Most application of \ac{DES} deal with dynamic, stochastic systems (e.g.
chemicals systems). In these cases the time advance $\text{ta}(s)$ often
involves drawing a sample from a statistical distribution (e.g. exponential
distribution for arrival times), making the state trajectory a realisation of a
stochastic process.

\subsection{Multi Agent-based Modeling and Simulation}


\subsection{Deterministic and Stochastic Simulation}
If the simulated model does not contain any probabilistic components, we talk
about \emph{deterministic} simulation. In such models the output is determined
once the set of input quantities and relationships in the model have been
specified. Hence, given a set of initial conditions and inputs, the output
trajectory is unique and reproducible. On the other hand, \emph{stochastic
simulation} introduces probabilistic elements: here the evolution is not a
single path but a realisation of a stochastic process. Stochasticity is
essential in systems where "average" behaviour (e.g. modeled by differential
equations) fails to capture reality. This can occur in \emph{low-granularity}
regimes, such as chemical reactions or particular \ac{MABS} scenario with
sparse populations, where fluctuations and rare events drive the system
dynamics.

In the context of Discrete Event Simulation, stochasticity typically manifests
in the Time Advance function $\text{ta}(s)$. The duration of a state is not
fixed but drawn from a probability distribution (commonly Exponential for
memoryless processes), making the event scheduling itself probabilistic (more
on this in \Cref{ssec:mdt}).

\subsection{Summary and Comparison}

\begin{table}[htbp]
    \centering
    \caption{Comparison of Simulation Formalisms}
    \label{tab:sim_comparison}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Feature} & \textbf{DTSS} & \textbf{DESS} & \textbf{DEVS} \\
        \midrule
        \textbf{Time Advance} & Fixed Step ($\Delta t$) & Fixed/Variable Step & Event-Driven (Jumps) \\
        \textbf{State Change} & Discrete & Continuous & Discrete \\
        \textbf{Computation} & Regular / Predictable & Intensive (Solver) & Activity-Dependent \\
        \textbf{Best For} & Cellular Automata, physics & Mechanics, Fluids & Queues, Chemistry, Logic \\
        \bottomrule
    \end{tabular}
\end{table}

\section{The Dependency Problem}
\subsection{Manual Dependency Tracking}\label{ssec:mdt}
