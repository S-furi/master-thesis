%!TEX root = ../thesis-main.tex
\chapter{An Introduction to Simulation}\label{ch:introduction}
The scientific method is characterised by the formulation of a \emph{theory}
which needs to be proven as false or true. This forms the first scientific
pillar, which is the theoretical assumption and knowledge used to describe a
certain phenomena, a property or a behaviour. The process of gathering evidence
to support the validity of the theory is what \emph{experiments} try to
accomplish, namely a series of observations of the real world that confirm or
refute the initial hypothesis. In the modern era of sciences, computer systems
backs the vast majority of modern scientific discoveries, whether through the
usage of the raw computing power (e.g. weather forecasting equations resolution
through Massively Parallel Computers) of such systems or by exploiting virtual
representations of the real world ~\cite{Post2005-kn}. With the widespread
adoption of simulation and simulators in the scientific method, researchers are
now considering simulation as the \emph{third pillar} of science which
complements theory and experiments. Some argues that simulation cannot be
compared to experimentation, while others claim that there is more in common
between simulation and experimentation ~\cite{WinsbergEric2010Sita}.
In the general scientific method framework, theory provides the model of the
hypothesis, while through experiments some may validate those models against
reality, while simulation can serve as sources of new insights or new
hypothesis which will be tested experimentally. Therefore, simulation is
essential in most scientific development workflows, and modern literature has
plenty of successful applications of simulations in various fields from biology
to physics and from chemistry to social sciences.

\section{Simulation and Modelling}
\subsection{System Modelling concepts}
\subsection{The Simulation Framework}

\section{Simulation Formalisms}

\subsection{Discrete Time Simulators}\label{ssec:dts}

The Discrete Time Model assumes a \emph{stepwise} mode of execution where, at a
particular time instant, the model is in a particular state and it defines how
this state changes. Based on its current state and the current input, the model
can determine which will be its state and output in the next time instant.
\emph{Time} in discrete time models advances in discrete steps of integers
multiple of some basic period such as 1 second, 1 day or 1 year.

A discrete time model determines its next state and output at a given time
$t$ with the following functions:

\begin{subequations}
	 \begin{align}
		q(t + 1) & = \delta(q(t), x(t)) \label{eq:state_transition} \\
		y(t) & = \lambda(q(t), x(t)) \label{eq:output_transition}
	 \end{align}
\end{subequations}
Starting from an initial state $q(0)$, we determine the \emph{state trajectory}
$q(0), q(1), \dots$ by applying the \emph{state transition function}
\eqref{eq:state_transition}; similarly, by applying the \emph{output function}
\eqref{eq:output_transition} to the initial state, we obtain the \emph{output
trajectory}.

\paragraph{Cellular Automata as Discrete Time Models:}

With these simple functions a wide spectrum of potentially interesting and
arbitrary complex models could be created. A notable example of modeling and
thereafter simulating models defined through simple state transition and output
functions are \emph{Cellular Automata} ~\cite{Neumann:66}. A
cellular automaton has a set of \emph{cells} (potentially infinite) spatially
located in a grid-like space, where each one of them could have a finite set of
states determined by a set of state transition functions identical for each
cell. State transition functions could be influenced by the
\emph{neighbourhood} of the cell, which most of the time is defined as the set
of cells located nearest in the geometrical sense.

The basic procedure for simulating a cellular automaton is by means of the
discrete time simulation algorithm: at each time tick, every cell of the
environment is scanned and the state transition function is applied,
effectively changing states for those cells whose state transition function
produced a new state different from its current. When all next states have been
computed, the current configuration of all cells constitute the new global
state, and the global tick can advance.

It is rather obvious that either for infinite environment or for particularly
large and complex cellular automata, this approach is unfeasible. If at each
time step we could, instead, ``predict'' which cells could change in the next
time step, the amount of state computation for each step is dramatically
reduced (e.g. in Conway's Game of Life). We could define which cells will
change in the next time step as the cells whose neighboring cells have not
changed at the current state transition time. This key idea is behind the
Discrete Event Simulation algorithm, which focuses on processing events (a cell
state change which will trigger a computation of new possibile states for its
neighbours) rather than single cells.

\subsection{Differential Equation Simulators}\label{ssec:dess}

Unlike Discrete Time Models and Discrete Event Models (discussed later in
\Cref{ssec:devs}) where state changes happen at specific time instants, in
Differential Equations Models the next state is not specified directly but a
\emph{rate of change} of the state variables is used to express the evolution
of the model through time. This means that at any particular time instant $t$,
given a state $z$ and an input value $u$, we only know the rate of change of
the state, defined as:
%
\begin{equation}
	\frac{dz}{dt} = f(z, u)
\end{equation}
%
Typically continuous time systems are expressed by using several state
variables, meaning that a continuous time model is formed by a set of \ac{ODE}.
Therefore we can express the \emph{state equation} representation of \ac{ODE}
as:
%
\begin{equation}
	\frac{d\mathbf{z}(t)}{dt} = \mathbf{f}(\mathbf{z}(t), \mathbf{u}(t))
\end{equation}
%
where $\mathbf{z}(t) \triangleq [z_1(t), z_2(t), \dots, z_n(t)]^T$ is the state
vector, the input vector $\mathbf{u}(t) \triangleq [u_1(t), u_2(t), \dots,
u_n(t)]$ and $\mathbf{f} \triangleq [f_1, f_2, \dots, f_n]$ is the vector of
differential equations.

To obtain the state trajectory, the \ac{ODE} must be solved. Solving an
\ac{ODE} \emph{analytically} is often impossible, especially for non-linear
systems. Therefore, simulations utilize numerical integration methods (e.g.
Euler's method, Runge-Kutta for one-step methods, ...). It is also important to
note that because digital computers operate in discrete steps, simulating a
Differential Equation System effectively reduces it to a form of Discrete Time
System. The numerical solver discretises time into small steps $\Delta t$,
calculating ~\cite{cellier2006continuous}:
%
\begin{equation}
    \mathbf{z}(t + \Delta t) \approx \mathbf{z}(t) + \mathbf{f}(\mathbf{z}(t), \mathbf{u}(t)) \cdot \Delta t
\end{equation}
%
Thus, in the context of computer simulation, DESS is often treated as a
special, computationally intensive case of discrete time simulation
~\cite{law2007simulation} with a very fine temporal granularity.

\subsection{Discrete Event Simulators}\label{ssec:devs}
While Discrete Time models advance in fixed steps, Discrete Event models are
characterised by a continuous time base where state changes occur only at
discrete instants called \emph{events}. Between two consecutive events, the
system's state remains unchanged, allowing the simulator to jump over periods
of inactivity, making \ac{DES} highly efficient for sparse systems.

A Discrete Event System (DEVS) can be specified as:
%
\begin{equation}
	M = \langle X, S, Y, \delta_{\text{int}}, \delta_{\text{ext}}, \lambda, \text{ta} \rangle
\end{equation}
%
Where the key components distinguishing from DTSS and DESS are:
\begin{itemize}
	\item \textbf{Time Advance} $\text{ta}: S \rightarrow \mathbb{R}^+_{0,
		\infty}$: a function returning the system remains in a
		particular state if no external events occur, defining the
		lifespan of a state. If $\text{ta}(s) = 0$ the state is so
		short that no other event can intervene (\emph{transitory
		state}), whereas $\text{ta}(s) = \infty$ means that the system
		remains in $s$ indefinitely, unless interrupted by an external
		event;
	\item \textbf{Internal Transition} $\delta_{\text{int}}: S \rightarrow S$: this
		function dictates the new state $s' : \delta_{\text{int}}(s) =
		s'$ after the time $\text{ta}(s)$ has elapsed (autonomous state
		change);
	\item \textbf{External Transition} $\delta_{\text{ext}}: Q \times X
		\rightarrow S$: given the total state set $Q = \{ (s, e) : s
		\in S, 0 \leq e \leq \text{ta}(s)\}$, this function dictates
		the new state $s' = \delta_{\text{ext}}(s, x, e)$ when an input
		$x$ is received in state $s$ after elapsed time $e$.
\end{itemize}
Through this formal definition we can highlight that time in DEVS is not a
global ticker, but a derived property of the system's state via the time
advance function.

\paragraph{DES Simulation Mechanism (Event Scheduling):} To execute a formal
DEVS model on a digital computer, the most common approach is by the
\emph{Event Scheduling} method ~\cite{BanksDESS10}. The simulator maintains a
strictly ordered data queue known as the \ac{FEL}, which stores pending events
ordered by their execution time.
The execution proceeds as a sequence of system \emph{snapshots}:
%
\begin{enumerate}
	\item The clock is advanced to the time of the imminent event at the head of the \ac{FEL};
	\item The event is removed from the \ac{FEL} and executed (either applying $\delta_{\text{int}}$ or $\delta_{\text{ext}}$);
	\item The execution may generate new events or cancel or update existing ones by updating the contents of the \ac{FEL};
	\item The process repeats until \ac{FEL} is empty or a termination condition occurs.
\end{enumerate}
%
Most application of \ac{DES} deal with dynamic, stochastic systems (e.g.
chemicals systems). In these cases the time advance $\text{ta}(s)$ often
involves drawing a sample from a statistical distribution (e.g. exponential
distribution for arrival times), making the state trajectory a realisation of a
stochastic process.

\subsection{Multi Agent-based Modeling and Simulation}


\subsection{Deterministic and Stochastic Simulation}
If the simulated model does not contain any probabilistic components, we talk about
deterministic simulation. In such models the output is determined once the set of input
quantities and relationships in the model have been specified.
On the other hand, when some random input components are introduced, these give
raise to stochastic simulation models. Thanks to stochastic models, the output of
a stochastic simulation is itself random and therefore should be treated as only
an estimate of the true characteristics of the model.

\subsection{Summary and Comparison}

\begin{table}[htbp]
    \centering
    \caption{Comparison of Simulation Formalisms}
    \label{tab:sim_comparison}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Feature} & \textbf{DTSS} & \textbf{DESS} & \textbf{DEVS} \\
        \midrule
        \textbf{Time Advance} & Fixed Step ($\Delta t$) & Fixed/Variable Step & Event-Driven (Jumps) \\
        \textbf{State Change} & Discrete & Continuous & Discrete \\
        \textbf{Computation} & Regular / Predictable & Intensive (Solver) & Activity-Dependent \\
        \textbf{Best For} & Cellular Automata, physics & Mechanics, Fluids & Queues, Chemistry, Logic \\
        \bottomrule
    \end{tabular}
\end{table}
